Blank Solution
Class Library(.NET Standart) -> Bll, Dal, Entities (projelere týkla bu 2.0'ý böyle yap "netstandard2.1" EntityFramework için önemli)
Asp.Net Core Web Application -> CoreUI

BLL ->Data Access -> Manager
DAL ->Repository
ENTITIES ->Model
UI->Presentation

Gerekli kütüphaneler indirilmeli 

Entities -> Models,Enums
  
DAL  ("Dependency Injection" Baselerin constructorý sayesinde) (Entities katmanýndan referans almalý)

**Repositorylerde her class için interface class açmanýn nedeni var. Her bir class için interface repository açmamýz lazým çünkü "Dependency Injection" tetiklenmeli. Eðer yapmazsak Startup.cs içine yazdýðýmýz;
		//services.AddTransient<IProductRepository,ProductRepository>();  kullanamayýz. yani demektir ki her interface için ayrý nesne ver instance al demektir.

	Context -> MyContext: Eðer kurmak istediðimiz veri tabaný yapýsýnda Identity kullanacaksak DbContext'ten miras almamalýyýz. Çünkü Identity kendi tablolarý tamamen hazýr bir yapý sunar ve bu hazýr yapýyý DbContext saðlayamaz. Miras alacaðýmýz sýnýf "IdentityDbContext" olmalý
	Repositories
		Abstract:
		Her bir class için interface repository açmamýz lazým çünkü "Dependency Injection" tetiklenmeli. Classlar IRepositoryden miras aldýðý için implement edilmek zorunda deðil
				IRepository 
					public interface IRepository<T> where T:BaseEntity (metodlarýmýzý yazýyoruz)
				IProductRepository
					public interface IProductRepository:IRepository<Product> 
		Concretes:
		Her class için class tipinde repository açýlmalý. BaseRepositoryde olmalý ki kod tekrarý olmasýn. Daha sonra abstract interface classlarý 
				BaseRepository (implement interface)(Constructor açýlmalý: MyContext _db; prmtr MyContext db)
					public class BaseRepository<T> : IRepository<T> where T : BaseEntity
						BaseRepositoryi abstract yapmamýza gerek yok. Çünkü Manager katmanýnda instance almamýz lazým. Bu contstructor sayesinde Dependency Injection yaparýz.
				ProductRepository (class isminin altýna kýrmýzý çizgi gelir constructorda halledilmeli(MyContext db):base(db))
					public class ProductRepository:BaseRepository<Product>,IProductRepository

UI	
	(BLLden reference almalý ancak Bll de ENTITIES ve DALdan referans aldýðý için oradaki classlar burada gözükür)

	**Ancak gidipte MyContexti Startup.cs içine yazmak doðru olmaz
	**Böylece Bll içindeki kütüphaneler de bu katmanda görünür

BLL ("Dependency Injection" Baselerin constructorý sayesinde) (DAL ve ENTITIESden referance almalý) 
	ManagerServices klasörü aç
		Abstract: (her class için)
			IManager
				public interface IManager<T> where T:BaseEntity 
					Bu sýnýfa da IRepositorydeki gibi "Add" metodu ekleyeceðiz ancak burada önemli bir nokta var. DAL katmaný data access yani veri eriþimi ile ilgili olduðu için IRepository içindeki "Add" metodu sorgulamadan ekleme yapacak. Ancak BLL yani iþ katmanýmýzda bu ekleme iþlemini sorgulayacak hatta hata mesajý bile döndürebilir.
			IProductManager
				public interface IProductManager:IManager<Product>
		Concretes:
			BaseManager (implement interface metod virtual olmalý)
				public class BaseManager<T> : IManager<T> where T : BaseEntity
				protected IRepository<T> _irp;
				Constructor açýlmalý: (IRepository<T> _irp; prmtr IRepository<T> irp) bu contstructor sayesinde Dependency Injection yaparýz.
			ProductManager
				public class ProductManager:BaseManager<Product>,IProductManager
				(Constructor)  public ProductManager(IRepository<Product> prp):base(prp)
				override ederiz. (Polymorphism)

Startup->ConfigureService->services.AddAuthentication();
Startup->Configure->add.UseAuthentication();

Þimdi öyle bir þey yapmalýyýz ki IRepository geldiðinde BaseRepository yaratmalý Core projesi. 
KATMAN BAÐIMSIZ DEPENDENCY INJECTION (notlarý var) Hem Autofac olmadan hem de Autofac ile Dependency Injection yapýlacak

BLL içine 
Manuel Dependency Injection (Tetikleme: Startup.cs->ConfigureServices)
	ServiceExtension klasörü açýp içine aþaðýdaki classlarý açýyoruz
		DbContextService -> Veritabaný configurasyon ayarlarýný yapar -> services.AddDbContextService();
		IdentityExtensionService -> Þifreleme, User,Role,Authorize gibi iþlemlerin hazýr olduðu kütüphanedir -> services.AddIdentityService();
		RepManServiceExtension -> Extension metodu ile servisi kullanýr -> services.AddRepAndManServices();
	
Autofac Dependency Injection(Tetikleme: Program.cs->buradaki IHostBuilder'da ConfigureWebHostDefaults'dan önce ekleme yapmamýz lazým-> .ConfigureServices(x=>x.AddAutofac()).UseServiceProviderFactory(new AutofacServiceProviderFactory()).ConfigureContainer<ContainerBuilder>(builder=>
            {
                builder.RegisterModule(new AutofacBusinessModule());        
            }
            ))
	DependencyResolvers klasörü açtýk
		AutofacBusinessModule -> yukarýdaki Manuel Dependency Injection için oluþturduðumuz tüm classlarý burada topluyoruz

	
************************************ MÝMARÝ TAMAMLANDI ****************************************

Dal katmanýnda IRepository içine iþimize yarayacak tüm metodlarý yazabiliriz. Implement ettiðin BaseRepositoryde Linq; kütüphanesini ekle. Ayný iþlemi iþ katmaný için BLL içinde IManager içinde metod ekleyip BaseManagerda implement et   

CoreUI

Controller->CategoryController

Models->PageVM->CategoryPageVM

Controllerda IActionlarý açýp Viewlarý düzenledik

Migration yapmak için çalýþan proje UI katmaný olmalý. DAL katmanýný ise Consoleda seçmek gerekir.



**Identity Kütüphanesini kullandýðýmýz için veritabanýnda otomatik olarak "Role, User, Login" gibi classlar oluþtu. Bunlarýn kontrolünü ele alabiliriz ancak bunun için yalnýzca "BLL" yani iþ katmanýnýnda Manage kýsmýna Login, User abstract interfaceleri ekleyip Concreteslere de eklesek bize yeterli olur. Ayrýyeten  DAL katmanýnda Repository, Entitiesde class eklemeye gerek yok.
Bll
	ManageServices->Abstracts                    Concretes
		ILoginManager								 LoginManager			
		IUserManagerSpecial							 UserManagerSpecial

**Identity'in kendi Userýný kullanmak istersek yukarýdaki classlarda kullanmak istediðimiz class "IdentityUser"'dýr.

IUserManagerSpecialýn miras verdiði UserManagerSpecial sýnýfýnda interfacei implement edeceðiz
	Bu iþlemi AutofacBusinessModule içinde RegisterType ile tip ddeðiþimine maruz býrakmamýz lazým (tüm abstracts ve concretes için)


AccountController açtýk 
	Register Iactioný açtýk yalnýz asenkron olmalý çünkü bizim UserManagerSpecial içinde kullandýðýmýz AddUser Metodumuz asenkron 
	(Bu eziyetlerle uðraþmamýzýn nedeni sadece Identity kütüphanesini kullanmamýzdan dolayý)

	RegisterSuccess Iactioný da açtýk üye olduðunda doðrulama yapmasý için

***AutofacBusinessModule sýnýfýmýzda 34. satýrdaki ni.AddIdentity'e password, kullanýcý ismi gibi propertylerin limitleri belirledik. Mesela password en az 5 karakterli olmalý

Register iþlemi tamamlandýktan sonra veritabanýna baktýðýmýzda þifreyi kendisi hushlamýþ oluyor. Bu identity kütüphanesi sayesindedir. Ama biz kendi þifreleme sýnýfýmýzý yazabiliriz 

	Login Iactioný açtýk 


	 ***Tamamem authorization yapmak için gidip mesela Category classýnda action ya da direkt classýn isminin	üstüne [Authorize] yazmamýz lazým
		Bir action bu iþlemden etkilenmemesi için [AllowAnonymous] demek gerekir.

***Yukarýdaki Authorize iþlemini yaptýðýmýz iþin Logini actioný direkt kendisi çalýþýr. Startup.cs klasöründe Category controllerýna yönlendirme yapmýþ olmamýza raðmen Authorize iþleminden dolayý gider bize önce Login yapmamýz gerektirðini söyler
	Ancak biz "Remember Me" clicki ekledik bu sayede tarayýcý bizi Session olarak tutar. Bunu saðlayan da Identity kütüphanesidir.



	********************************* INTERFACELERÝ TEKRAR ET ************************************

			MVC
			Eriþim belirteci default olarak PUBLIC
			Buradaki metodlarýn yaþam alanlarý olamaz ancak bu sadece MVCde geçerlidir. 

			CORE
			.NET Coreda c# 8.0dan sonra hem eriþim belirteci hem de yaþam alaný verebiliriz


	Bunlara ek olarak biz kendi oluþturduðumuz classlarý da Identity kütüphanesi ile birleþtirebiliriz   

Entities 

	CoreInterface   
		IEntity (Dependency Injection)
			BaseEntity classýna buradan miras vereceðiz
			Dal katmanýnda BaseRepositorye de miras alýnan sýnýf olarak eklenmeli

			Mülakat Soru:
			Dependency Injectionýnda sorun olmamasý için tip kýsýtlamasý yerine interface eklemek gerekir. BaseRepository IEntity eklemek gibi  